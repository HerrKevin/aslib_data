*** SQL queries ***
For future reference: the arff files in this folder can be regenerated using the OpenML SQL editor. If any of these queries stop working (e.g., because of database changes), let me know at joaquin.vanschoren@gmail.com.

Feature values
--------------
select d.name as instance_id, "1" as repetition, group_concat(IF(dq.quality = "DefaultAccuracy", dq.value,NULL)) AS `DefaultAccuracy`,
group_concat(IF(dq.quality = "EntropyClass", dq.value,NULL)) AS `EntropyClass`,
group_concat(IF(dq.quality = "EquivalentNumberOfFeatures", dq.value,NULL)) AS `EquivalentNumberOfFeatures`,
group_concat(IF(dq.quality = "LandMarker1NN", dq.value,NULL)) AS `LandMarker1NN`,
group_concat(IF(dq.quality = "LandMarker1Rule", dq.value,NULL)) AS `LandMarker1Rule`,
group_concat(IF(dq.quality = "LandmarkerNaiveBayes", dq.value,NULL)) AS `LandmarkerNaiveBayes`,
group_concat(IF(dq.quality = "MStatisticDegreesOfFreedom", dq.value,NULL)) AS `MStatisticDegreesOfFreedom`,
group_concat(IF(dq.quality = "MutualInformationMean", dq.value,NULL)) AS `MutualInformationMean`,
group_concat(IF(dq.quality = "NoiseToSignalRatio", dq.value,NULL)) AS `NoiseToSignalRatio`,
group_concat(IF(dq.quality = "NumberOfClasses", dq.value,NULL)) AS `NumberOfClasses`,
group_concat(IF(dq.quality = "NumberOfFeatures", dq.value,NULL)) AS `NumberOfFeatures`,
group_concat(IF(dq.quality = "NumberOfInstances", dq.value,NULL)) AS `NumberOfInstances`,
group_concat(IF(dq.quality = "NumberOfInstancesWithMissingValues", dq.value,NULL)) AS `NumberOfInstancesWithMissingValues`,
group_concat(IF(dq.quality = "NumberOfMissingValues", dq.value,NULL)) AS `NumberOfMissingValues`,
group_concat(IF(dq.quality = "NumberOfNumericFeatures", dq.value,NULL)) AS `NumberOfNumericFeatures`,
group_concat(IF(dq.quality = "NumberOfSymbolicFeatures", dq.value,NULL)) AS `NumberOfSymbolicFeatures`
from data_quality dq, dataset d where dq.data = d.did and dq.quality in ('DefaultAccuracy', 'EntropyClass', 'EquivalentNumberOfFeatures', 'LandMarker1NN', 'LandMarker1Rule', 'LandmarkerNaiveBayes', 'MStatistic', 'MStatisticDegreesOfFreedom', 'MutualInformationMean', 'NoiseToSignalRatio', 'NumberOfClasses', 'NumberOfFeatures', 'NumberOfInstances', 'NumberOfInstancesWithMissingValues', 'NumberOfMissingValues', 'NumberOfNumericFeatures', 'NumberOfSymbolicFeatures', 'StandardDeviationRatio') and d.isOriginal='true' and d.collection='uci' group by d.name

Algorithm runs
--------------
SELECT name, @row_num := IF(@prev_value=concat_ws('',name,fullName),@row_num+1,1) AS RowNumber, fullName,
round(build_cpu_time,4), 
build_memory, 
round(predictive_accuracy,4),
round(root_mean_squared_error,4),
round(mean_absolute_error,4),
runstatus,
error, 
@prev_value := concat_ws('',name,fullName) as combo
from
(SELECT d.name, i.fullName,
e1.value as build_cpu_time, 
e2.value as build_memory, 
e3.value as predictive_accuracy, 
e4.value as root_mean_squared_error, 
e5.value as mean_absolute_error, 
rn.status as runstatus, rn.error
FROM run rn left join algorithm_setup l on (rn.setup = l.parent) left join implementation i on (l.implementation_id=i.id) left join dataset d on (rn.data=d.did) 
left join evaluation e1 on (e1.source=rn.rid and e1.function="build_cpu_time")
left join evaluation e2 on (e2.source=rn.rid and e2.function="build_memory")
left join evaluation e3 on (e3.source=rn.rid and e3.function="predictive_accuracy")
left join evaluation e4 on (e4.source=rn.rid and e4.function="root_mean_squared_error")
left join evaluation e5 on (e5.source=rn.rid and e5.function="mean_absolute_error")
where (rn.experiment=1 or rn.experiment=3) and i.fullName in ('weka.ADTree(1.2)', 'weka.AODE(1.8.2.3)', 'weka.AttributeSelectedClassifier(1.16.2.4)', 'weka.BayesNet(1.21.2.4)', 'weka.ClassificationViaRegression(1.20)', 'weka.DecisionStump(1.18)', 'weka.DecisionTable(1.29.2.1)', 'weka.FilteredClassifier(1.20.2.2)', 'weka.HyperPipes(1.15)', 'weka.IB1(1.13.2.1)', 'weka.IBk(1.32)', 'weka.Id3(1.14.2.1)', 'weka.LBR(1.4.2.2)', 'weka.LMT(1.2.2.1)', 'weka.LWL(1.12)', 'weka.Logistic(1.32)', 'weka.LogitBoost(1.33)', 'weka.NBTree(1.3.2.1)', 'weka.NNge(1.2.2.1)', 'weka.NaiveBayes(1.16)', 'weka.NaiveBayesSimple(1.13.2.2)', 'weka.NaiveBayesUpdateable(1.4)', 'weka.OneR(1.17)', 'weka.OrdinalClassClassifier(1.0)', 'weka.PART(1.2.2.1)', 'weka.Prism(1.17)', 'weka.Ridor(1.12)', 'weka.SimpleLogistic(1.5.2.1)', 'weka.VFI(1.9)', 'weka.Vote(1.7)', 'weka.ZeroR(1.11)', 'weka.AdaBoostM1(1.24.2.3)', 'weka.Bagging(1.31.2.2)', 'weka.CVParameterSelection(1.27.2.3)', 'weka.ConjunctiveRule(1.10)', 'weka.Decorate(1.3.2.1)', 'weka.J48(1.2)', 'weka.JRip(1.14)', 'weka.MultiBoostAB(1.6.2.2)','weka.MultiClassClassifier(1.37.2.2)', 'weka.MultiScheme(1.18.2.1)', 'weka.MultilayerPerceptron(1.2)', 'weka.RBFNetwork(1.4)', 'weka.REPTree(1.19.2.2)', 'weka.RacedIncrementalLogitBoost(1.4.2.2)', 'weka.RandomForest(1.6)', 'weka.RandomTree(1.8.2.2)', 'weka.SMO(1.53.2.2)', 'weka.Stacking(1.23.2.1)', 'weka.StackingC(1.8)') order by name, fullName asc) as a, 
(SELECT @row_num := 1) x,
(SELECT @prev_value := '') y order by combo
